diff --git a/src/TODO b/src/TODO
index 5f93c808..1f537c66 100644
--- a/src/TODO
+++ b/src/TODO
@@ -15,6 +15,7 @@ Pero putpixel de maquina emulada sin raibow tiene el 0,0 dentro de border. Como
 y luego mezclarlos... problema: drivers como cocoa hace el render el solito, con la memoria de pantalla.
 fbdev pasa lo mismo. Habria que tener un buffer intermedio (cuando menu esta activo) y mezclarlos a cada final de frame
 ->esto implicaria alterar funcion de putpixel de driver de video por otro cuando se abre el menu. Demasiado complicado
+->habria que sumar scr_return_margenxy_rainbow a la llamada a scr_ver_si_refrescar_por_menu_activo cuando rainbow
 
 -cpc sin footer y zoom 2 peta en Mac
 
diff --git a/src/screen.c b/src/screen.c
index 91054a06..45666a29 100644
--- a/src/screen.c
+++ b/src/screen.c
@@ -1913,6 +1913,72 @@ void set_putpixel_zoom(void)
 	}
 }
 
+
+void scr_putpixel_gui_zoom_no_rainbow(int x,int y,unsigned int color)
+{
+
+#ifdef PUTPIXELCACHE
+        int indice_cache;
+				if (MACHINE_IS_Z88) {
+                indice_cache=(get_total_ancho_rainbow()*(y)) + x;
+        }
+
+        else if (MACHINE_IS_CPC) {
+                indice_cache=(get_total_ancho_rainbow()*(CPC_TOP_BORDER_NO_ZOOM*border_enabled.v+y)) + CPC_LEFT_BORDER_NO_ZOOM*border_enabled.v+x;
+        }
+
+        else if (MACHINE_IS_PRISM) {
+                indice_cache=(get_total_ancho_rainbow()*(PRISM_TOP_BORDER_NO_ZOOM*border_enabled.v+y)) + PRISM_LEFT_BORDER_NO_ZOOM*border_enabled.v+x;
+        }
+
+                                else if (MACHINE_IS_TSCONF) {
+                                        indice_cache=(get_total_ancho_rainbow()*(TSCONF_TOP_BORDER_NO_ZOOM*border_enabled.v+y)) + TSCONF_LEFT_BORDER_NO_ZOOM
+*border_enabled.v+x;
+                                }
+
+                                else if (MACHINE_IS_TBBLUE) {
+                                        indice_cache=(get_total_ancho_rainbow()*(TBBLUE_TOP_BORDER_NO_ZOOM*border_enabled.v+y)) + TBBLUE_LEFT_BORDER_NO_ZOOM
+*border_enabled.v+x;
+                                }
+
+        else if (MACHINE_IS_SAM) {
+                indice_cache=(get_total_ancho_rainbow()*(SAM_TOP_BORDER_NO_ZOOM*border_enabled.v+y)) + SAM_LEFT_BORDER_NO_ZOOM*border_enabled.v+x;
+        }
+
+                                else if (MACHINE_IS_QL) {
+                                                                          indice_cache=(get_total_ancho_rainbow()*(QL_TOP_BORDER_NO_ZOOM*border_enabled.v+y)) + QL_LEFT_BORDER_NO_ZOOM*border_enabled.v+x;
+                                                        }
+
+        else {
+                indice_cache=(get_total_ancho_rainbow()*(screen_borde_superior*border_enabled.v+y)) + screen_total_borde_izquierdo*border_enabled.v+x;
+        }
+
+
+				//indice_cache=(get_total_ancho_rainbow()*(y)) + x;				
+
+				if (putpixel_cache[indice_cache]==color) return;
+
+        //printf ("scr_putpixel_zoom not in cache: x %d y %d indice_cache=%d \n",x,y,indice_cache);
+        //put_putpixel_cache(indice_cache,color);
+        putpixel_cache[indice_cache]=color;
+#endif
+
+	     int zx,zy;
+			 
+			    int xzoom=x*zoom_x;
+        int yzoom=y*zoom_y;
+
+
+
+        //Escalado a zoom indicado
+        for (zx=0;zx<zoom_x;zx++) {
+                for (zy=0;zy<zoom_y;zy++) {
+                        scr_putpixel(xzoom+zx,yzoom+zy,color);
+                }
+        }
+}
+
+
 //Hacer un putpixel en la coordenada indicada pero haciendo tan gordo el pixel como diga zoom_level
 void scr_putpixel_gui_zoom(int x,int y,int color,int zoom_level)
 { 
@@ -1923,7 +1989,8 @@ void scr_putpixel_gui_zoom(int x,int y,int color,int zoom_level)
 			//printf("putpixel %d,%d\n",x+incx,y+incy);
 			if (rainbow_enabled.v==1) scr_putpixel_zoom_rainbow(x+incx,y+incy,color);
 
-			else scr_putpixel_zoom(x+incx,y+incy,color);
+			//else scr_putpixel_zoom(x+incx,y+incy,color);
+			else scr_putpixel_gui_zoom_no_rainbow(x+incx,y+incy,color);
 		}
 	}
 }
@@ -1999,8 +2066,10 @@ void scr_putchar_menu_comun_zoom(z80_byte caracter,int x,int y,z80_bit inverse,z
 
 	scr_return_margenxy_rainbow(&margenx_izq,&margeny_arr);
 
+	//printf ("%d %d\n",margenx_izq,margeny_arr);
+
 	//temp prueba
-	//margenx_izq=margeny_arr=0;
+	margenx_izq=margeny_arr=0;
 
 	//Caso de pentagon y en footer
 	if (pentagon_timing.v && y>=31) margeny_arr=56*border_enabled.v;
@@ -2026,18 +2095,11 @@ void scr_putchar_menu_comun_zoom(z80_byte caracter,int x,int y,z80_bit inverse,z
 			yfinal=y*zoom_level;
 
 			if (rainbow_enabled.v==1) {
-				//xfinal=(((x*menu_char_width)+bit)*zoom_level);
 				xfinal +=margenx_izq;
 
-				//yfinal=y*zoom_level;
 				yfinal +=margeny_arr;
 			}
 
-			else {
-				//xfinal=((x*menu_char_width)+bit)*zoom_level;
-				//yfinal=y*zoom_level;
-			}
-
 
 			//Hacer zoom de ese pixel si conviene
 
@@ -2060,8 +2122,6 @@ void scr_putchar_menu_comun_zoom(z80_byte caracter,int x,int y,z80_bit inverse,z
 				if (bit!=0 && bit!=6 && bit!=7) scr_putpixel_gui_zoom(xfinal,yfinal,color,zoom_level);
 			}
 
-	
-
 
 
     }
@@ -2123,17 +2183,12 @@ void scr_putsprite_comun_zoom(z80_byte *puntero,int x,int y,z80_bit inverse,z80_
 		yfinal=y*zoom_level;
 
 		if (rainbow_enabled.v==1) {
-			//xfinal=(((x*8)+bit)*zoom_level);
 			xfinal +=margenx_izq;
 
-			//yfinal=y*zoom_level;
 			yfinal +=margeny_arr;
 		}
 
-		else {
-			//xfinal=((x*8)+bit)*zoom_level;
-			//yfinal=y*zoom_level;
-		}
+
 
 
 		//Hacer zoom de ese pixel si conviene		
@@ -2371,11 +2426,30 @@ for (y=0;y<192;y+=8) {
 int scr_ver_si_refrescar_por_menu_activo(int x,int fila)
 {
 
+  int margenx_izq;
+  int margeny_arr;
+
+	if (rainbow_enabled.v) {
+  	scr_return_margenxy_rainbow(&margenx_izq,&margeny_arr);
+	}
+
+	else {
+		margenx_izq=margeny_arr=0;
+	}
+
+	//scr_return_margenxy_rainbow(&margenx_izq,&margeny_arr);
+
+	margenx_izq /=8;
+	margeny_arr /=8;
+
+	x +=margenx_izq;
+	fila +=margeny_arr;
+
+
+
 	x /=menu_gui_zoom;
 	fila /=menu_gui_zoom;
 
-	//menu_char_width
-	//x=(x*menu_char_width)/8;
 
 	if (x>31 || fila>23) return 1;
 
